<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[基于TK1 & Manifold的实时目标检测(HOG+SVM代码详解)]]></title>
      <url>/2017/04/17/HOG_Code/</url>
      <content type="html"><![CDATA[<p>在前文中，我们对HOG+SVM算法应用于目标实时检测给出了简单的理论介绍，本文将从实践出发，在TK1(Manifold)使用OpenCV完成目标检测。<br>安装环境请参考前面的文章。本例中使用环境为CUDA-6.5和OpenCV-3.1.0。</p>
<h1 id="训练前期准备"><a href="#训练前期准备" class="headerlink" title="训练前期准备"></a>训练前期准备</h1><h3 id="收集训练图片及图像预处理"><a href="#收集训练图片及图像预处理" class="headerlink" title="收集训练图片及图像预处理"></a>收集训练图片及图像预处理</h3><p>  收集大量目标样本图片，注意以下两点。<br>  在正样本图片中尽量不要出现其他干扰因素。<br>  正样本图像尺寸比例尽量与实际目标比例相等。</p>
<p>  收集背景图片(负样本)，注意背景图片尺寸必须一致，背景图片中不能出现目标。</p>
<p>  用Python对正样本进行Resize：<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> PIL</div><div class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</div><div class="line"><span class="keyword">import</span> os</div><div class="line"></div><div class="line"><span class="comment">#正样本图片路径</span></div><div class="line">path = <span class="string">"posImgs/"</span></div><div class="line">files = os.listdir(path)</div><div class="line"><span class="keyword">for</span> name <span class="keyword">in</span> files:</div><div class="line">	img = Image.open(path+name)</div><div class="line">	img = img.resize((<span class="number">80</span>, <span class="number">80</span>), PIL.Image.ANTIALIAS)</div><div class="line">	img.save(name)</div></pre></td></tr></table></figure></p>
<h1 id="使用OpenCV训练SVM分类器"><a href="#使用OpenCV训练SVM分类器" class="headerlink" title="使用OpenCV训练SVM分类器"></a>使用OpenCV训练SVM分类器</h1><p>   在工程目录下建立pos文件夹用于放置所有Resize过的正样本图片，建立neg放置所有负样本图片。<br>   创建train.cpp以及CMakeLists.txt。</p>
<p>   train.cpp 代码如下<br>   使用时请在main函数中修改训练样本路径<br>   <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _DEBUG false</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv::ml;</div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_svm_detector</span><span class="params">(<span class="keyword">const</span> Ptr&lt;SVM&gt;&amp; svm, <span class="built_in">vector</span>&lt; <span class="keyword">float</span> &gt; &amp; hog_detector )</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">convert_to_ml</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; cv::Mat &gt; &amp; train_samples, cv::Mat&amp; trainData )</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">load_images</span><span class="params">( <span class="keyword">const</span> <span class="built_in">string</span> &amp; prefix, <span class="built_in">vector</span>&lt; Mat &gt; &amp; img_lst )</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sample_neg</span><span class="params">( <span class="keyword">const</span> <span class="built_in">vector</span>&lt; Mat &gt; &amp; full_neg_lst, <span class="built_in">vector</span>&lt; Mat &gt; &amp; neg_lst, <span class="keyword">const</span> Size &amp; size )</span></span>;</div><div class="line"><span class="function">Mat <span class="title">get_hogdescriptor_visu</span><span class="params">(<span class="keyword">const</span> Mat&amp; color_origImg, <span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;&amp; descriptorValues, <span class="keyword">const</span> Size &amp; size )</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute_hog</span><span class="params">( <span class="keyword">const</span> <span class="built_in">vector</span>&lt; Mat &gt; &amp; img_lst, <span class="built_in">vector</span>&lt; Mat &gt; &amp; gradient_lst, <span class="keyword">const</span> Size &amp; size )</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">train_svm</span><span class="params">( <span class="keyword">const</span> <span class="built_in">vector</span>&lt; Mat &gt; &amp; gradient_lst, <span class="keyword">const</span> <span class="built_in">vector</span>&lt; <span class="keyword">int</span> &gt; &amp; labels )</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw_locations</span><span class="params">( Mat &amp; img, <span class="keyword">const</span> <span class="built_in">vector</span>&lt; Rect &gt; &amp; locations, <span class="keyword">const</span> Scalar &amp; color )</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_it</span><span class="params">( <span class="keyword">const</span> Size &amp; size )</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_svm_detector</span><span class="params">(<span class="keyword">const</span> Ptr&lt;SVM&gt;&amp; svm, <span class="built_in">vector</span>&lt; <span class="keyword">float</span> &gt; &amp; hog_detector )</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// get the support vectors</span></div><div class="line">    Mat sv = svm-&gt;getSupportVectors();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> sv_total = sv.rows;</div><div class="line">    <span class="comment">// get the decision function</span></div><div class="line">    Mat alpha, svidx;</div><div class="line">    <span class="keyword">double</span> rho = svm-&gt;getDecisionFunction(<span class="number">0</span>, alpha, svidx);</div><div class="line"></div><div class="line">    CV_Assert( alpha.total() == <span class="number">1</span> &amp;&amp; svidx.total() == <span class="number">1</span> &amp;&amp; sv_total == <span class="number">1</span> );</div><div class="line">    CV_Assert( (alpha.type() == CV_64F &amp;&amp; alpha.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>) == <span class="number">1.</span>) ||</div><div class="line">               (alpha.type() == CV_32F &amp;&amp; alpha.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>) == <span class="number">1.f</span>) );</div><div class="line">    CV_Assert( sv.type() == CV_32F );</div><div class="line">    hog_detector.clear();</div><div class="line"></div><div class="line">    hog_detector.resize(sv.cols + <span class="number">1</span>);</div><div class="line">    <span class="built_in">memcpy</span>(&amp;hog_detector[<span class="number">0</span>], sv.ptr(), sv.cols*<span class="keyword">sizeof</span>(hog_detector[<span class="number">0</span>]));</div><div class="line">    hog_detector[sv.cols] = (<span class="keyword">float</span>)-rho;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">* Convert training/testing set to be used by OpenCV Machine Learning algorithms.</div><div class="line">* TrainData is a matrix of size (#samples x max(#cols,#rows) per samples), in 32FC1.</div><div class="line">* Transposition of samples are made if needed.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">convert_to_ml</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; cv::Mat &gt; &amp; train_samples, cv::Mat&amp; trainData )</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//--Convert data</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> rows = (<span class="keyword">int</span>)train_samples.size();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> cols = (<span class="keyword">int</span>)<span class="built_in">std</span>::max( train_samples[<span class="number">0</span>].cols, train_samples[<span class="number">0</span>].rows );</div><div class="line">    cv::<span class="function">Mat <span class="title">tmp</span><span class="params">(<span class="number">1</span>, cols, CV_32FC1)</span></span>; <span class="comment">//&lt; used for transposition if needed</span></div><div class="line">    trainData = cv::Mat(rows, cols, CV_32FC1 );</div><div class="line">    <span class="built_in">vector</span>&lt; Mat &gt;::const_iterator itr = train_samples.begin();</div><div class="line">    <span class="built_in">vector</span>&lt; Mat &gt;::const_iterator end = train_samples.end();</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; itr != end ; ++itr, ++i )</div><div class="line">    &#123;</div><div class="line">        CV_Assert( itr-&gt;cols == <span class="number">1</span> ||</div><div class="line">                   itr-&gt;rows == <span class="number">1</span> );</div><div class="line">        <span class="keyword">if</span>( itr-&gt;cols == <span class="number">1</span> )</div><div class="line">        &#123;</div><div class="line">            transpose( *(itr), tmp );</div><div class="line">            tmp.copyTo( trainData.row( i ) );</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( itr-&gt;rows == <span class="number">1</span> )</div><div class="line">        &#123;</div><div class="line">            itr-&gt;copyTo( trainData.row( i ) );</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">load_images</span><span class="params">( <span class="keyword">const</span> <span class="built_in">string</span> &amp; prefix, <span class="built_in">vector</span>&lt; Mat &gt; &amp; img_lst )</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;String&gt; files;</div><div class="line">    glob(prefix, files);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; files.size(); ++i)</div><div class="line">    &#123;</div><div class="line"></div><div class="line">        Mat img = imread(files[i]); <span class="comment">// load the image</span></div><div class="line">        <span class="keyword">if</span> (img.empty()) <span class="comment">// invalid image, just skip it.</span></div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; files[i] &lt;&lt; <span class="string">" is invalid!"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></div><div class="line"></div><div class="line">        imshow(<span class="string">"image"</span>, img);</div><div class="line">        waitKey(<span class="number">10</span>);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">        img_lst.push_back(img);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sample_neg</span><span class="params">( <span class="keyword">const</span> <span class="built_in">vector</span>&lt; Mat &gt; &amp; full_neg_lst, <span class="built_in">vector</span>&lt; Mat &gt; &amp; neg_lst, <span class="keyword">const</span> Size &amp; size )</span></span></div><div class="line">&#123;</div><div class="line">    Rect box;</div><div class="line">    box.width = size.width;</div><div class="line">    box.height = size.height;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> size_x = box.width;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> size_y = box.height;</div><div class="line"></div><div class="line">    srand( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)time( <span class="literal">NULL</span> ) );</div><div class="line"></div><div class="line">    <span class="built_in">vector</span>&lt; Mat &gt;::const_iterator img = full_neg_lst.begin();</div><div class="line">    <span class="built_in">vector</span>&lt; Mat &gt;::const_iterator end = full_neg_lst.end();</div><div class="line">    <span class="keyword">for</span>( ; img != end ; ++img )</div><div class="line">    &#123;</div><div class="line">        box.x = rand() % (img-&gt;cols - size_x);</div><div class="line">        box.y = rand() % (img-&gt;rows - size_y);</div><div class="line">        Mat roi = (*img)(box);</div><div class="line">        neg_lst.push_back( roi.clone() );</div><div class="line">        imshow( <span class="string">"img"</span>, roi.clone() );</div><div class="line">        waitKey(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// From http://www.juergenwiki.de/work/wiki/doku.php?id=public:hog_descriptor_computation_and_visualization</span></div><div class="line"><span class="function">Mat <span class="title">get_hogdescriptor_visu</span><span class="params">(<span class="keyword">const</span> Mat&amp; color_origImg, <span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt;&amp; descriptorValues, <span class="keyword">const</span> Size &amp; size )</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> DIMX = size.width;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> DIMY = size.height;</div><div class="line">    <span class="keyword">float</span> zoomFac = <span class="number">3</span>;</div><div class="line">    Mat visu;</div><div class="line">    resize(color_origImg, visu, Size( (<span class="keyword">int</span>)(color_origImg.cols*zoomFac), (<span class="keyword">int</span>)(color_origImg.rows*zoomFac) ) );</div><div class="line"></div><div class="line">    <span class="keyword">int</span> cellSize        = <span class="number">8</span>;</div><div class="line">    <span class="keyword">int</span> gradientBinSize = <span class="number">9</span>;</div><div class="line">    <span class="keyword">float</span> radRangeForOneBin = (<span class="keyword">float</span>)(CV_PI/(<span class="keyword">float</span>)gradientBinSize); <span class="comment">// dividing 180 into 9 bins, how large (in rad) is one bin?</span></div><div class="line"></div><div class="line">    <span class="comment">// prepare data structure: 9 orientation / gradient strenghts for each cell</span></div><div class="line">    <span class="keyword">int</span> cells_in_x_dir = DIMX / cellSize;</div><div class="line">    <span class="keyword">int</span> cells_in_y_dir = DIMY / cellSize;</div><div class="line">    <span class="keyword">float</span>*** gradientStrengths = <span class="keyword">new</span> <span class="keyword">float</span>**[cells_in_y_dir];</div><div class="line">    <span class="keyword">int</span>** cellUpdateCounter   = <span class="keyword">new</span> <span class="keyword">int</span>*[cells_in_y_dir];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y=<span class="number">0</span>; y&lt;cells_in_y_dir; y++)</div><div class="line">    &#123;</div><div class="line">        gradientStrengths[y] = <span class="keyword">new</span> <span class="keyword">float</span>*[cells_in_x_dir];</div><div class="line">        cellUpdateCounter[y] = <span class="keyword">new</span> <span class="keyword">int</span>[cells_in_x_dir];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;cells_in_x_dir; x++)</div><div class="line">        &#123;</div><div class="line">            gradientStrengths[y][x] = <span class="keyword">new</span> <span class="keyword">float</span>[gradientBinSize];</div><div class="line">            cellUpdateCounter[y][x] = <span class="number">0</span>;</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> bin=<span class="number">0</span>; bin&lt;gradientBinSize; bin++)</div><div class="line">                gradientStrengths[y][x][bin] = <span class="number">0.0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// nr of blocks = nr of cells - 1</span></div><div class="line">    <span class="comment">// since there is a new block on each cell (overlapping blocks!) but the last one</span></div><div class="line">    <span class="keyword">int</span> blocks_in_x_dir = cells_in_x_dir - <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> blocks_in_y_dir = cells_in_y_dir - <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">// compute gradient strengths per cell</span></div><div class="line">    <span class="keyword">int</span> descriptorDataIdx = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> cellx = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> celly = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> blockx=<span class="number">0</span>; blockx&lt;blocks_in_x_dir; blockx++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> blocky=<span class="number">0</span>; blocky&lt;blocks_in_y_dir; blocky++)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">// 4 cells per block ...</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> cellNr=<span class="number">0</span>; cellNr&lt;<span class="number">4</span>; cellNr++)</div><div class="line">            &#123;</div><div class="line">                <span class="comment">// compute corresponding cell nr</span></div><div class="line">                cellx = blockx;</div><div class="line">                celly = blocky;</div><div class="line">                <span class="keyword">if</span> (cellNr==<span class="number">1</span>) celly++;</div><div class="line">                <span class="keyword">if</span> (cellNr==<span class="number">2</span>) cellx++;</div><div class="line">                <span class="keyword">if</span> (cellNr==<span class="number">3</span>)</div><div class="line">                &#123;</div><div class="line">                    cellx++;</div><div class="line">                    celly++;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> bin=<span class="number">0</span>; bin&lt;gradientBinSize; bin++)</div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">float</span> gradientStrength = descriptorValues[ descriptorDataIdx ];</div><div class="line">                    descriptorDataIdx++;</div><div class="line"></div><div class="line">                    gradientStrengths[celly][cellx][bin] += gradientStrength;</div><div class="line"></div><div class="line">                &#125; <span class="comment">// for (all bins)</span></div><div class="line"></div><div class="line"></div><div class="line">                <span class="comment">// note: overlapping blocks lead to multiple updates of this sum!</span></div><div class="line">                <span class="comment">// we therefore keep track how often a cell was updated,</span></div><div class="line">                <span class="comment">// to compute average gradient strengths</span></div><div class="line">                cellUpdateCounter[celly][cellx]++;</div><div class="line"></div><div class="line">            &#125; <span class="comment">// for (all cells)</span></div><div class="line"></div><div class="line"></div><div class="line">        &#125; <span class="comment">// for (all block x pos)</span></div><div class="line">    &#125; <span class="comment">// for (all block y pos)</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// compute average gradient strengths</span></div><div class="line">    <span class="keyword">for</span> (celly=<span class="number">0</span>; celly&lt;cells_in_y_dir; celly++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (cellx=<span class="number">0</span>; cellx&lt;cells_in_x_dir; cellx++)</div><div class="line">        &#123;</div><div class="line"></div><div class="line">            <span class="keyword">float</span> NrUpdatesForThisCell = (<span class="keyword">float</span>)cellUpdateCounter[celly][cellx];</div><div class="line"></div><div class="line">            <span class="comment">// compute average gradient strenghts for each gradient bin direction</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> bin=<span class="number">0</span>; bin&lt;gradientBinSize; bin++)</div><div class="line">            &#123;</div><div class="line">                gradientStrengths[celly][cellx][bin] /= NrUpdatesForThisCell;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// draw cells</span></div><div class="line">    <span class="keyword">for</span> (celly=<span class="number">0</span>; celly&lt;cells_in_y_dir; celly++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (cellx=<span class="number">0</span>; cellx&lt;cells_in_x_dir; cellx++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> drawX = cellx * cellSize;</div><div class="line">            <span class="keyword">int</span> drawY = celly * cellSize;</div><div class="line"></div><div class="line">            <span class="keyword">int</span> mx = drawX + cellSize/<span class="number">2</span>;</div><div class="line">            <span class="keyword">int</span> my = drawY + cellSize/<span class="number">2</span>;</div><div class="line"></div><div class="line">            rectangle(visu, Point((<span class="keyword">int</span>)(drawX*zoomFac), (<span class="keyword">int</span>)(drawY*zoomFac)), Point((<span class="keyword">int</span>)((drawX+cellSize)*zoomFac), (<span class="keyword">int</span>)((drawY+cellSize)*zoomFac)), Scalar(<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>), <span class="number">1</span>);</div><div class="line"></div><div class="line">            <span class="comment">// draw in each cell all 9 gradient strengths</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> bin=<span class="number">0</span>; bin&lt;gradientBinSize; bin++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">float</span> currentGradStrength = gradientStrengths[celly][cellx][bin];</div><div class="line"></div><div class="line">                <span class="comment">// no line to draw?</span></div><div class="line">                <span class="keyword">if</span> (currentGradStrength==<span class="number">0</span>)</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">                <span class="keyword">float</span> currRad = bin * radRangeForOneBin + radRangeForOneBin/<span class="number">2</span>;</div><div class="line"></div><div class="line">                <span class="keyword">float</span> dirVecX = <span class="built_in">cos</span>( currRad );</div><div class="line">                <span class="keyword">float</span> dirVecY = <span class="built_in">sin</span>( currRad );</div><div class="line">                <span class="keyword">float</span> maxVecLen = (<span class="keyword">float</span>)(cellSize/<span class="number">2.f</span>);</div><div class="line">                <span class="keyword">float</span> scale = <span class="number">2.5</span>; <span class="comment">// just a visualization scale, to see the lines better</span></div><div class="line"></div><div class="line">                <span class="comment">// compute line coordinates</span></div><div class="line">                <span class="keyword">float</span> x1 = mx - dirVecX * currentGradStrength * maxVecLen * scale;</div><div class="line">                <span class="keyword">float</span> y1 = my - dirVecY * currentGradStrength * maxVecLen * scale;</div><div class="line">                <span class="keyword">float</span> x2 = mx + dirVecX * currentGradStrength * maxVecLen * scale;</div><div class="line">                <span class="keyword">float</span> y2 = my + dirVecY * currentGradStrength * maxVecLen * scale;</div><div class="line"></div><div class="line">                <span class="comment">// draw gradient visualization</span></div><div class="line">                line(visu, Point((<span class="keyword">int</span>)(x1*zoomFac),(<span class="keyword">int</span>)(y1*zoomFac)), Point((<span class="keyword">int</span>)(x2*zoomFac),(<span class="keyword">int</span>)(y2*zoomFac)), Scalar(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>), <span class="number">1</span>);</div><div class="line"></div><div class="line">            &#125; <span class="comment">// for (all bins)</span></div><div class="line"></div><div class="line">        &#125; <span class="comment">// for (cellx)</span></div><div class="line">    &#125; <span class="comment">// for (celly)</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// don't forget to free memory allocated by helper data structures!</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y=<span class="number">0</span>; y&lt;cells_in_y_dir; y++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;cells_in_x_dir; x++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">delete</span>[] gradientStrengths[y][x];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">delete</span>[] gradientStrengths[y];</div><div class="line">        <span class="keyword">delete</span>[] cellUpdateCounter[y];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">delete</span>[] gradientStrengths;</div><div class="line">    <span class="keyword">delete</span>[] cellUpdateCounter;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> visu;</div><div class="line"></div><div class="line">&#125; <span class="comment">// get_hogdescriptor_visu</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute_hog</span><span class="params">( <span class="keyword">const</span> <span class="built_in">vector</span>&lt; Mat &gt; &amp; img_lst, <span class="built_in">vector</span>&lt; Mat &gt; &amp; gradient_lst, <span class="keyword">const</span> Size &amp; size )</span></span></div><div class="line">&#123;</div><div class="line">    HOGDescriptor hog;</div><div class="line">    hog.winSize = size;</div><div class="line">    Mat gray;</div><div class="line">    <span class="built_in">vector</span>&lt; Point &gt; location;</div><div class="line">    <span class="built_in">vector</span>&lt; <span class="keyword">float</span> &gt; descriptors;</div><div class="line">  </div><div class="line">    <span class="built_in">vector</span>&lt; Mat &gt;::const_iterator img = img_lst.begin();</div><div class="line">    <span class="built_in">vector</span>&lt; Mat &gt;::const_iterator end = img_lst.end();</div><div class="line">    <span class="keyword">for</span>( ; img != end ; ++img )</div><div class="line">    &#123;</div><div class="line">        cvtColor( *img, gray, COLOR_BGR2GRAY );</div><div class="line">        hog.compute( gray, descriptors, Size( <span class="number">8</span>, <span class="number">8</span> ), Size( <span class="number">0</span>, <span class="number">0</span> ), location );</div><div class="line">        gradient_lst.push_back( Mat( descriptors ).clone() );</div><div class="line">        imshow( <span class="string">"gradient"</span>, get_hogdescriptor_visu( img-&gt;clone(), descriptors, size ) );</div><div class="line">        waitKey( <span class="number">0</span> );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">train_svm</span><span class="params">( <span class="keyword">const</span> <span class="built_in">vector</span>&lt; Mat &gt; &amp; gradient_lst, <span class="keyword">const</span> <span class="built_in">vector</span>&lt; <span class="keyword">int</span> &gt; &amp; labels )</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">    Mat train_data;</div><div class="line">    convert_to_ml( gradient_lst, train_data );</div><div class="line"></div><div class="line">    <span class="built_in">clog</span> &lt;&lt; <span class="string">"Start training..."</span>;</div><div class="line">    Ptr&lt;SVM&gt; svm = SVM::create();</div><div class="line">    <span class="comment">/* Default values to train SVM */</span></div><div class="line">    svm-&gt;setCoef0(<span class="number">0.0</span>);</div><div class="line">    svm-&gt;setDegree(<span class="number">3</span>);</div><div class="line">    svm-&gt;setTermCriteria(TermCriteria( CV_TERMCRIT_ITER+CV_TERMCRIT_EPS, <span class="number">1000</span>, <span class="number">1e-3</span> ));</div><div class="line">    svm-&gt;setGamma(<span class="number">0</span>);</div><div class="line">    svm-&gt;setKernel(SVM::LINEAR);</div><div class="line">    svm-&gt;setNu(<span class="number">0.5</span>);</div><div class="line">    svm-&gt;setP(<span class="number">0.1</span>); <span class="comment">// for EPSILON_SVR, epsilon in loss function?</span></div><div class="line">    svm-&gt;setC(<span class="number">0.01</span>); <span class="comment">// From paper, soft classifier</span></div><div class="line">    svm-&gt;setType(SVM::EPS_SVR); <span class="comment">// C_SVC; // EPSILON_SVR; // may be also NU_SVR; // do regression task</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    </div><div class="line"></div><div class="line">    svm-&gt;train(train_data, ROW_SAMPLE, Mat(labels));</div><div class="line">    <span class="built_in">clog</span> &lt;&lt; <span class="string">"...[done]"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    svm-&gt;save( <span class="string">"armour.yml"</span> );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw_locations</span><span class="params">( Mat &amp; img, <span class="keyword">const</span> <span class="built_in">vector</span>&lt; Rect &gt; &amp; locations, <span class="keyword">const</span> Scalar &amp; color )</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>( !locations.empty() )</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">vector</span>&lt; Rect &gt;::const_iterator loc = locations.begin();</div><div class="line">        <span class="built_in">vector</span>&lt; Rect &gt;::const_iterator end = locations.end();</div><div class="line">        <span class="keyword">for</span>( ; loc != end ; ++loc )</div><div class="line">        &#123;</div><div class="line">            rectangle( img, *loc, color, <span class="number">2</span> );</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="built_in">vector</span>&lt; Mat &gt; pos_lst;</div><div class="line">    <span class="built_in">vector</span>&lt; Mat &gt; full_neg_lst;</div><div class="line">    <span class="built_in">vector</span>&lt; Mat &gt; neg_lst;</div><div class="line">    <span class="built_in">vector</span>&lt; Mat &gt; gradient_lst;</div><div class="line">    <span class="built_in">vector</span>&lt; <span class="keyword">int</span> &gt; labels;</div><div class="line">    <span class="built_in">string</span> pos_dir = <span class="string">"/home/sunny/HOG/HOG_train/pos/"</span>;</div><div class="line">    <span class="built_in">string</span> neg_dir = <span class="string">"/home/sunny/HOG/HOG_train/neg/"</span>;</div><div class="line">  </div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"positive images are being loaded."</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    load_images( pos_dir, pos_lst );</div><div class="line"></div><div class="line">    Size pos_image_size = pos_lst[<span class="number">0</span>].size();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; pos_lst.size(); ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>( pos_lst[i].size() != pos_image_size)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"All positive images should be same size!"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">            <span class="built_in">exit</span>( <span class="number">-1</span> );</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    labels.assign( pos_lst.size(), +<span class="number">1</span> );</div><div class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> old = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)labels.size();</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"negative images are being loaded."</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    load_images( neg_dir, full_neg_lst );</div><div class="line">    sample_neg( full_neg_lst, neg_lst, pos_image_size );</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"negative images have finished."</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    labels.insert( labels.end(), neg_lst.size(), <span class="number">-1</span> );</div><div class="line">    CV_Assert( old &lt; labels.size() );</div><div class="line"></div><div class="line">    compute_hog( pos_lst, gradient_lst, pos_image_size );</div><div class="line">    compute_hog( neg_lst, gradient_lst, pos_image_size );</div><div class="line"></div><div class="line">    train_svm( gradient_lst, labels );</div><div class="line"></div><div class="line"></div><div class="line">     <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">  </div></pre></td></tr></table></figure></p>
<p>CMakeLists.txt<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">project (train)</div><div class="line"><span class="built_in">set</span>(SRC_LIST train.cpp)</div><div class="line"></div><div class="line">find_package( OpenCV 3.1 REQUIRED )</div><div class="line"><span class="built_in">set</span>(SOURCE_FILES train.cpp)</div><div class="line">add_executable(train <span class="variable">$&#123;SOURCE_FILES&#125;</span>)</div><div class="line">target_link_libraries(train <span class="variable">$&#123;OpenCV_LIBS&#125;</span>)</div></pre></td></tr></table></figure></p>
<p>准备好上述文件后执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cmake -D CMAKE_BUILD_TYPE=RELESE .</div><div class="line">$ make</div><div class="line">$ ./train</div></pre></td></tr></table></figure></p>
<p>运行结束后将得到一个.yml文件，该文件即为我们训练好的SVM分类器。</p>
]]></content>
      
        <categories>
            
            <category> 计算机视觉 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[基于TK1 & Manifold的实时目标检测(HOG-SVM方法)]]></title>
      <url>/2017/04/16/HOG/</url>
      <content type="html"><![CDATA[<p>本文提出了一个基于 TK1 微型处理器的目标检测与识别系统,使用 HOG(histogram of oriented gradient)进行特征提取,SVM(support vector machine) 进行分类。针对不同的目标检测识别的情景下,给出了方案的最优化调整方式。 算法结合 TK1 性能强大的 GPU 模块,准确度与速度在实时条件下都具有良好的 表现,可广泛应用于各类微型机器人以及要求整体体积小、功耗低、实时反应好的情景。</p>
<h1 id="系统总览"><a href="#系统总览" class="headerlink" title="系统总览"></a>系统总览</h1><p>本系统包含两大模块,硬件模块与软件模块。硬件模块采用 TK1 嵌入式设备 与摄像头模组;软件模块采用 HOG(histogram of oriented gradient)特征提取算 法,SVM(support vector machine)机器学习分类算法,该算法对于光照变化及对比 度变化有良好的鲁棒性,配合 TK1 中的 CUDA 核心识别速度性能良好。我们提 出的方法将在下文中以识别装甲块的案例中详细介绍。</p>
<p><img src="/2017/04/16/HOG/p2.png" alt="&quot;系统总览&quot;"></p>
<h1 id="SVM训练分类器"><a href="#SVM训练分类器" class="headerlink" title="SVM训练分类器"></a>SVM训练分类器</h1><p>分类器的训练是为了从一副输入的区域图像中判断其中是否包含目标物体。从训练集样本中提取每张图片的HOG特征,它代表了图像中的梯度水平。Sobel算子用来计算每个像素点的水平和垂直梯度值。我们发现 HOG 特征对于识别有特定纹理的目标有着良好的表现,包括本例中的装甲块,数字,字母,各类标志在现实情景中都是直立面对摄像头,这消除了由于目标旋转及几何失真带来的误差。</p>
<h3 id="1-gt-训练集样本图片预处理"><a href="#1-gt-训练集样本图片预处理" class="headerlink" title="1&gt;训练集样本图片预处理"></a>1&gt;训练集样本图片预处理</h3><p>将所有样本图片裁剪为统一尺寸,本例中统一为 80px*80px.</p>
<h3 id="2-gt-计算像素点梯度"><a href="#2-gt-计算像素点梯度" class="headerlink" title="2&gt;计算像素点梯度"></a>2&gt;计算像素点梯度</h3><p>使用 Sobel 算子计算处理后的图像梯度。<br><img src="/2017/04/16/HOG/gradient-kernels.png" alt="Sobel"><br>通过以下公式得出梯度强度值 g 及角度θ。</p>
<p><img src="/2017/04/16/HOG/t0.png" alt=""></p>
<h3 id="3-gt-在8-8cell内计算梯度直方图"><a href="#3-gt-在8-8cell内计算梯度直方图" class="headerlink" title="3&gt;在8*8cell内计算梯度直方图"></a>3&gt;在8*8cell内计算梯度直方图</h3><p>将图像分成8<em>8的cell，将每一个小块作为一个统计单位。每一个cell内包含64个像素，每个像素有强度及角度两个值。角度的取值范围为0至180,将每一个8</em>8小块进行统计，最终会得到一个能描述每个小块纹理特征的梯度直方图.</p>
<p><img src="/2017/04/16/HOG/tidu.png" alt="gradient"></p>
<h3 id="4-gt-Block区域整合"><a href="#4-gt-Block区域整合" class="headerlink" title="4&gt;Block区域整合"></a>4&gt;Block区域整合</h3><p>将4个cell整合成一个16<em>16的Block，每个cell根据直方图可得到一个9</em>1的向量，一个窗口将包含一个36<em>1的向量。取步长为1，将窗口在整个80</em>80的图像上滑动，将得到36<em>9</em>9=2916维的特征向量，Block尺寸K及N维的特征向量计算用以下公式：<br><img src="/2017/04/16/HOG/r1.png" alt=""><br><img src="/2017/04/16/HOG/r2.png" alt=""><br>R为输入图像的尺寸，M为cell尺寸，B为每个Block内的cell数量，R为直方图内的统计分量数量。本例中，R=80<em>80，M=8</em>8，B=4，R=9。</p>
<h3 id="5-gt-训练SVM分类器"><a href="#5-gt-训练SVM分类器" class="headerlink" title="5&gt;训练SVM分类器"></a>5&gt;训练SVM分类器</h3><p>SVM是一种通过构建一个超平面完成对数据的分类。SVM分类快速，高度准确，相比其他分类方法不容易出现过拟合。也可以很快地训练，SVM分类器对于要求速度与准确度的实时目标检测与识别表现极为出色。我们这里使用linear kernel的SVM模型，通过大量正样本与负样本的训练，我们可以得到一个SVM分类器，为了最优化该分类器的准确度，我们需要对一个控制损失函数的C值进行设置，C值过大将造成过拟合，C值过小将造成欠拟合，因此，我们将用交叉验证集测评，使交叉验证集准确度最高的C值将被选择。<br><img src="/2017/04/16/HOG/Cvalue.png" alt="梯度示意图"></p>
<h1 id="目标实时检测"><a href="#目标实时检测" class="headerlink" title="目标实时检测"></a>目标实时检测</h1><p>   通过前面的步骤，我们已经完成了分类器的训练，现在我们可以将其运用于TK1上完成目标识别任务。实时条件下利用SVM分类器对目标进行识别的原理（如图2）<br>首先从摄像头读取一帧图像进行Gamma校正或者直方图均衡化后，利用图像金字塔以一定倍数ɑ进行缩放，接着在每一幅图像用尺寸为K的窗口进行滑动，步长为S，计算每个被窗口截取的图像的梯度直方图，得到向量N并将其输入SVM分类器可得到结果，在所有数据处理完后，可得到该副图像中是否有目标物体，若有，则可进行其他操作，操作完成后，读取下一帧画面。<br>   在上述过程中，我们需要讨论2个极为重要的参数，缩放倍数ɑ，步长S。这两个参数设置将将决定我们整个系统的速度与准确度。下面我们将详细讨论这两个参数。</p>
<p>#缩放倍数ɑ<br>  为了对多尺寸目标的识别，我们必须对输入图像进行一定倍数的缩放，直到缩放后的图像尺寸达到我们预先设置好的阈值，而每次的缩放倍数就是ɑ。我们可以想象当ɑ越小时，我们的检测准确率将会越高，然而我们需要处理更多的图片数据，这使我们系统的速度降低；当ɑ越大时，我们的准确率会下降，系统的速度会上升。<br><img src="/2017/04/16/HOG/jzt.png" alt="图像金字塔"></p>
<p>#步长S<br>步长S的数值代表了窗口每次水平或者竖直移动的距离。同样，如果S值较小，窗口移动得越慢，程序将计算每一块区域，需要处理的图像就越多，准确度越高，速度越低；反之，程序可能漏掉一些区域，准确度越低，速度越高。<br><img src="/2017/04/16/HOG/p3.png" alt="图像金字塔"><br>如何选择缩放倍数ɑ，与步长S要根据系统具体的应用情境去设置，对于要求准确度极高，但是对实时性要求不高的情境，可以选择较小ɑ与S；在对要求实时很高的情境下，可以适当增加ɑ与S的值。</p>
<h1 id="在TK1中测试"><a href="#在TK1中测试" class="headerlink" title="在TK1中测试"></a>在TK1中测试</h1><p>我们使用OpenCV将上述算法应用在TK1中，结合CUDA我们使用TK1的GPU完成大部分运算操作。我们的测试数据为3个640*480的MP4视频文件，调整了缩放比率ɑ与步长S得到了以下的实验结果。从中我们可以得出缩放比率ɑ、步长S、FPS、精度之间的大致关系。过大的步长S将严重影响精度，在步长S=8时，缩放比率控制在1.3至1.5之间将得到一个较高的精度与FPS。所以在本试验中，我们设置ɑ=1.4，S=8将使我们的系统达到最优性能。<br><img src="/2017/04/16/HOG/acc.png" alt="图像金字塔"><br><img src="/2017/04/16/HOG/fps.png" alt="图像金字塔"></p>
]]></content>
      
        <categories>
            
            <category> 计算机视觉 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Manifold & TK1 安装 CUDA OpenCV]]></title>
      <url>/2017/01/31/hello-world/</url>
      <content type="html"><![CDATA[<p>本文将介绍在TK1及Manifold安装机器视觉开发环境。</p>
<h2 id="安装CUDA"><a href="#安装CUDA" class="headerlink" title="安装CUDA"></a>安装CUDA</h2><h3 id="在Manifold-amp-TK1安装-deb-文件以及CUDA-Toolkit"><a href="#在Manifold-amp-TK1安装-deb-文件以及CUDA-Toolkit" class="headerlink" title="在Manifold &amp; TK1安装.deb 文件以及CUDA Toolkit"></a>在Manifold &amp; TK1安装.deb 文件以及CUDA Toolkit</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 下载源文件</span></div><div class="line">$ wget http://developer.download.nvidia.com/compute/cuda/6_5/rel/installers/cuda-repo<span class="_">-l</span>4t-r21.2-6-5-prod_6.5-34_armhf.deb</div><div class="line">$ sudo dpkg -i cuda-repo<span class="_">-l</span>4t-r21.2-6-5-prod_6.5-34_armhf.deb</div><div class="line">$ sudo apt-get update</div><div class="line">$ sudo apt-get install cuda-toolkit-6-5</div><div class="line">$ sudo usermod <span class="_">-a</span> -G video <span class="variable">$USER</span></div></pre></td></tr></table></figure>
<h3 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">echo</span> <span class="string">"# Add CUDA bin &amp; library paths:"</span> &gt;&gt; ~/.bashrc</div><div class="line">$ <span class="built_in">echo</span> <span class="string">"export PATH=/usr/local/cuda/bin:<span class="variable">$PATH</span>"</span> &gt;&gt; ~/.bashrc</div><div class="line">$ <span class="built_in">echo</span> <span class="string">"export LD_LIBRARY_PATH=/usr/local/cuda/lib:<span class="variable">$LD_LIBRARY_PATH</span>"</span> &gt;&gt; ~/.bashrc</div><div class="line">$ <span class="built_in">source</span> ~/.bashrc</div></pre></td></tr></table></figure>
<h3 id="查看-CUDA-ToolKit"><a href="#查看-CUDA-ToolKit" class="headerlink" title="查看 CUDA ToolKit"></a>查看 CUDA ToolKit</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ nvcc -V</div></pre></td></tr></table></figure>
<p>至此 CUDA 6.5 安装完成</p>
<h2 id="安装OpenCV"><a href="#安装OpenCV" class="headerlink" title="安装OpenCV"></a>安装OpenCV</h2><h3 id="OpenCV类型及选择"><a href="#OpenCV类型及选择" class="headerlink" title="OpenCV类型及选择"></a>OpenCV类型及选择</h3><p> 在Manifold &amp; TK1 上，有三种版本的OpenCV可供使用,我们需要从以下三个版本中选择一个进行安装</p>
<p>1&gt; 普通OpenCV<br>2&gt; 带有GPU加速的OpenCV(使用CUDA的普通OpenCV)<br>3&gt; 带有GPU和CPU加速的OpenCV4Tegra(NVIDIA优化版的OpenCV 2.4.X)</p>
<p>   对于拥有NVIDIA Kepler GPU、192个CUDA核心的Manifold和TK1来说，使用GPU计算是核心，普通OpenCV的性能表现将极差，所以我们不考虑此方案。<br>   对于方案2及方案3的选择就要依据具体项目而定了。<br>   使用方案2的优点是我们可以使用3.X版本的OpenCV,缺点是我们将失去CPU的优化加速。方案3虽然可以在CPU及GPU计算中同时得到加速，但是OpenCV4Tegra是基于OpenCV2.4.X的优化，个人感觉在使用上不如OpenCV3.X版本顺手，特别是在ml模块中。<br>   大部分在使用Manifold及TK1的项目的主要目的就是在实时条件下的目标识别，Haar Cascade Classifiers、LBP Cascade Classifiers、HOG+SVM是目前使用较为广泛的方法。Haar算法在GPU处理表现上与在CPU上表现大致相当，甚至略逊于CPU。LBP以及HOG算法在GPU处理表现非常出色，GPU处理速度可达CPU处理的5-20倍<a href="http://elinux.org/Jetson/Computer_Vision_Performance#Hardware_Acceleration_of_OpenCV" target="_blank" rel="external">(具体信息)</a>。大家可根据自己的项目，自行选择方案2或方案3进行安装。</p>
<p>   注意！！只能选择一个方案进行安装，在不少博客教程中都是先安装OpenCV4Tegra，接着又安装普通OpenCV，这样是错误的方法。使用哪一个直接安装即可。</p>
<h3 id="安装带有GPU加速的OpenCV-方案2"><a href="#安装带有GPU加速的OpenCV-方案2" class="headerlink" title="安装带有GPU加速的OpenCV(方案2)"></a>安装带有GPU加速的OpenCV(方案2)</h3><p>更新apt<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo add-apt-repository universe</div><div class="line">$ sudo apt-get update</div></pre></td></tr></table></figure></p>
<p>安装依赖<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get -y install build-essential make cmake cmake-curses-gui g++</div><div class="line">$ sudo apt-get -y install libavformat-dev libavutil-dev libswscale-dev</div><div class="line">$ sudo apt-get -y install libv4l-dev</div><div class="line">$ sudo apt-get -y install libeigen3-dev</div><div class="line">$ sudo apt-get -y install libglew1.6-dev</div><div class="line">$ sudo apt-get -y install libgtk2.0-dev</div></pre></td></tr></table></figure></p>
<p>安装OpenCV<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ wget https://github.com/Itseez/opencv/archive/3.1.0.zip</div><div class="line">$ unzip 3.1.0.zip</div><div class="line">$ <span class="built_in">cd</span> opencv-3.1.0</div><div class="line">$ mkdir build</div><div class="line">$ <span class="built_in">cd</span> build</div><div class="line">$ cmake -D WITH_CUDA=ON -D CUDA_ARCH_BIN=<span class="string">"3.2"</span> -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/<span class="built_in">local</span> -D BUILD_TESTS=OFF -D BUILD_PERF_TESTS=OFF -D ENABLE_NEON=ON ..</div><div class="line">$ sudo make -j4</div><div class="line">$ sudo make install</div></pre></td></tr></table></figure></p>
<p>至此方案2安装完成，可直接编写cpp文件及CMakeLists使用OpenCV3.1</p>
<h3 id="安装OpenCV4Tegra-方案3"><a href="#安装OpenCV4Tegra-方案3" class="headerlink" title="安装OpenCV4Tegra(方案3)"></a>安装OpenCV4Tegra(方案3)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ wget http://developer.download.nvidia.com/embedded/OpenCV/L4T_21.2/libopencv4tegra-repo_l4t-r21_2.4.10.1_armhf.deb</div><div class="line">$ sudo dpkg -i libopencv4tegra-repo_l4t-r21_2.4.10.1_armhf.deb</div><div class="line">$ sudo apt-get update</div><div class="line">$ sudo apt-get install libopencv4tegra libopencv4tegra-dev</div></pre></td></tr></table></figure>
<p>至此方案3安装完成，可直接编写cpp文件及CMakeLists使用OpenCV4Tegra</p>
]]></content>
      
        <categories>
            
            <category> 环境安装 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CUDA </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
